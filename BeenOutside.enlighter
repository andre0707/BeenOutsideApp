{"CodeGeneration":{"showViewHintComment":true,"uuidSerialization":"bytes","omitCreationSQL":false,"allowFoundation":true,"Raw":{"relationships":true,"hashable":true},"swiftFilters":true,"dateSerialization":"utime","qualifiedSelf":false,"commentsWithSQL":false,"propertyIndexPrefix":"idx_","Lighter":"no","optionalHelpersInDatabase":true,"readOnly":false,"generateAsyncFunctions":true,"inlinable":true,"embedRecordTypesInDatabaseType":false,"recordTypeAliasSuffix":"RecordType","public":true,"extraRecordTypeConformances":["Codable"]},"sql":"-- Enter SQL you'd like to create SQLite Swift code for, example:\n\nCREATE TABLE region_update (\n  region_update_id INTEGER PRIMARY KEY,\n  \n  date DATETIME NOT NULL,\n  update_type_raw TEXT NOT NULL,\n  region_name Text\n);\nPRAGMA user_version = 1;","EmbeddedLighter":{"selects":{"syncArray":{"columns":8,"sorts":2},"asyncArray":{"columns":8,"sorts":2},"syncYield":{"sorts":2,"columns":8}},"updates":{"keyBased":0,"predicateBased":0},"inserts":0},"swift":"import SQLite3\nimport Foundation\n\n\/**\n * A structure representing a SQLite database.\n * \n * ### Database Schema\n * \n * The schema captures the SQLite table\/view catalog as safe Swift types.\n * \n * #### Tables\n * \n * - ``RegionUpdate`` (SQL: `region_update`)\n * \n * > Hint: Use [SQL Views](https:\/\/www.sqlite.org\/lang_createview.html)\n * >       to create Swift types that represent common queries.\n * >       (E.g. joins between tables or fragments of table data.)\n * \n * Perform low level operations on ``RegionUpdate`` records:\n * ```swift\n * var db : OpaquePointer?\n * sqlite3_open_v2(path, &db, SQLITE_OPEN_READWRITE, nil)\n * \n * var records = RegionUpdate.fetch(in: db, orderBy: \"updateTypeRaw\", limit: 5) {\n *   $0.updateTypeRaw != nil\n * }\n * records[1].updateTypeRaw = \"Hunt\"\n * records[1].update(in: db)\n * \n * records[0].delete(in: db])\n * records[0].insert(db) \/\/ re-add\n * ```\n *\/\npublic struct BeenOutside {\n  \n  \/**\n   * A SQLError that can be used with SQLite\n   * \n   * Setup from SQLite3 database handle\n   * ```swift\n   * if rc != SQLITE_OK { throw SQLError(dbHandle) }\n   * ```\n   *\/\n  public struct SQLError : Swift.Error, Equatable {\n    \n    \/\/\/ The SQLite3 error code (`sqlite3_errcode`).\n    public let code : Int32\n    \n    \/\/\/ The SQLite3 error message (`sqlite3_errmsg`).\n    public let message : String?\n    \n    public init(_ code: Int32, _ message: UnsafePointer<CChar>? = nil)\n    {\n      self.code    = code\n      self.message = message.flatMap(String.init(cString:))\n    }\n    \n    public init(_ db: OpaquePointer!)\n    {\n      self.code    = sqlite3_errcode(db)\n      self.message = sqlite3_errmsg(db).flatMap(String.init(cString:))\n    }\n  }\n  \n  \/\/\/ User version of the database (`PRAGMA user_version`).\n  public static var userVersion = 1\n  \n  \/\/\/ Whether `INSERT â€¦ RETURNING` should be used (requires SQLite 3.35.0+).\n  public static var useInsertReturning = sqlite3_libversion_number() >= 3035000\n  \n  \/\/\/ The `DateFormatter` used for parsing string date values.\n  public static var dateFormatter : DateFormatter? = {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"yyyy-MM-dd HH:mm:ss\"\n    formatter.locale = Locale(identifier: \"en_US_POSIX\")\n    return formatter\n  }()\n  \n  \/\/\/ SQL that can be used to recreate the database structure.\n  @inlinable\n  public static var creationSQL : String {\n    var sql = \"\"\n    sql.append(RegionUpdate.Schema.create)\n    sql.append(#\"PRAGMA user_version = 1);\"#)\n    return sql\n  }\n  \n  \/**\n   * Create a SQLite3 database\n   * \n   * The database is created using the SQL `create` statements in the\n   * Schema structures.\n   * \n   * If the operation is successful, the open database handle will be\n   * returned in the `db` `inout` parameter.\n   * If the open succeeds, but the SQL execution fails, an incomplete\n   * database can be left behind. I.e. if an error happens, the path\n   * should be tested and deleted if appropriate.\n   * \n   * Example:\n   * ```swift\n   * var db : OpaquePointer!\n   * let rc = BeenOutside.create(path, in: &db)\n   * ```\n   * \n   * - Parameters:\n   *   - path: Path of the database.\n   *   - flags: Custom open flags.\n   *   - db: A SQLite3 database handle, if successful.\n   * - Returns: The SQLite3 error code (`SQLITE_OK` on success).\n   *\/\n  @inlinable\n  public static func create(\n    _ path: UnsafePointer<CChar>!,\n    _ flags: Int32 = SQLITE_OPEN_CREATE | SQLITE_OPEN_READWRITE,\n    `in` db: inout OpaquePointer?\n  ) -> Int32\n  {\n    let openrc = sqlite3_open_v2(path, &db, flags, nil)\n    if openrc != SQLITE_OK {\n      return openrc\n    }\n    let execrc = sqlite3_exec(db, BeenOutside.creationSQL, nil, nil, nil)\n    if execrc != SQLITE_OK {\n      sqlite3_close(db)\n      db = nil\n      return execrc\n    }\n    return SQLITE_OK\n  }\n  \n  public static func withOptCString<R>(\n    _ s: String?,\n    _ body: ( UnsafePointer<CChar>? ) throws -> R\n  ) rethrows -> R\n  {\n    if let s = s { return try s.withCString(body) }\n    else { return try body(nil) }\n  }\n}\n\n\/**\n * Record representing the `region_update` SQL table.\n * \n * Record types represent rows within tables&views in a SQLite database.\n * They are returned by the functions or queries\/filters generated by\n * Enlighter.\n * \n * Perform low level operations on ``RegionUpdate`` records:\n * ```swift\n * var db : OpaquePointer?\n * sqlite3_open_v2(path, &db, SQLITE_OPEN_READWRITE, nil)\n * \n * var records = RegionUpdate.fetch(in: db, orderBy: \"updateTypeRaw\", limit: 5) {\n *   $0.updateTypeRaw != nil\n * }\n * records[1].updateTypeRaw = \"Hunt\"\n * records[1].update(in: db)\n * \n * records[0].delete(in: db])\n * records[0].insert(db) \/\/ re-add\n * ```\n *\/\npublic struct RegionUpdate : Identifiable, Hashable, Codable {\n  \n  \/\/\/ Static SQL type information for the ``RegionUpdate`` record.\n  public static let schema = Schema()\n  \n  \/\/\/ Primary key `region_update_id` (`INTEGER`), optional (default: `nil`).\n  public var id : Int?\n  \n  \/\/\/ Column `date` (`DATETIME`), required (has default).\n  public var date : Date\n  \n  \/\/\/ Column `update_type_raw` (`TEXT`), required (has default).\n  public var updateTypeRaw : String\n  \n  \/\/\/ Column `region_name` (`TEXT`), optional (default: `nil`).\n  public var regionName : String?\n  \n  \/**\n   * Initialize a new ``RegionUpdate`` record.\n   * \n   * - Parameters:\n   *   - id: Primary key `region_update_id` (`INTEGER`), optional (default: `nil`).\n   *   - date: Column `date` (`DATETIME`), required (has default).\n   *   - updateTypeRaw: Column `update_type_raw` (`TEXT`), required (has default).\n   *   - regionName: Column `region_name` (`TEXT`), optional (default: `nil`).\n   *\/\n  @inlinable\n  public init(\n    id: Int? = nil,\n    date: Date,\n    updateTypeRaw: String,\n    regionName: String? = nil\n  )\n  {\n    self.id = id\n    self.date = date\n    self.updateTypeRaw = updateTypeRaw\n    self.regionName = regionName\n  }\n}\n\npublic extension RegionUpdate {\n  \n  \/**\n   * Fetch ``RegionUpdate`` records, filtering using a Swift closure.\n   * \n   * This is fetching full ``RegionUpdate`` records from the passed in SQLite database\n   * handle. The filtering is done within SQLite, but using a Swift closure\n   * that can be passed in.\n   * \n   * Within that closure other SQL queries can be done on separate connections,\n   * but *not* within the same database handle that is being passed in (because\n   * the closure is executed in the context of the query).\n   * \n   * Sorting can be done using raw SQL (by passing in a `orderBy` parameter,\n   * e.g. `orderBy: \"name DESC\"`),\n   * or just in Swift (e.g. `fetch(in: db).sorted { $0.name > $1.name }`).\n   * Since the matching is done in Swift anyways, the primary advantage of\n   * doing it in SQL is that a `LIMIT` can be applied efficiently (i.e. w\/o\n   * walking and loading all rows).\n   * \n   * If the function returns `nil`, the error can be found using the usual\n   * `sqlite3_errcode` and companions.\n   * \n   * Example:\n   * ```swift\n   * let records = RegionUpdate.fetch(in: db) { record in\n   *   record.name != \"Duck\"\n   * }\n   * \n   * let records = RegionUpdate.fetch(in: db, orderBy: \"name\", limit: 5) {\n   *   $0.firstname != nil\n   * }\n   * ```\n   * \n   * - Parameters:\n   *   - db: The SQLite database handle (as returned by `sqlite3_open`)\n   *   - sql: Optional custom SQL yielding ``RegionUpdate`` records.\n   *   - orderBySQL: If set, some SQL that is added as an `ORDER BY` clause (e.g. `name DESC`).\n   *   - limit: An optional fetch limit.\n   *   - filter: A Swift closure used for filtering, taking the``RegionUpdate`` record to be matched.\n   * - Returns: The records matching the query, or `nil` if there was an error.\n   *\/\n  @inlinable\n  static func fetch(\n    from db: OpaquePointer!,\n    sql customSQL: String? = nil,\n    orderBy orderBySQL: String? = nil,\n    limit: Int? = nil,\n    filter: @escaping ( RegionUpdate ) -> Bool\n  ) -> [ RegionUpdate ]?\n  {\n    withUnsafePointer(to: filter) { ( closurePtr ) in\n      guard Schema.registerSwiftMatcher(in: db, flags: SQLITE_UTF8, matcher: closurePtr) == SQLITE_OK else {\n        return nil\n      }\n      defer {\n        RegionUpdate.Schema.unregisterSwiftMatcher(in: db, flags: SQLITE_UTF8)\n      }\n      var sql = customSQL ?? RegionUpdate.Schema.matchSelect\n      if let orderBySQL = orderBySQL {\n        sql.append(\" ORDER BY \\(orderBySQL)\")\n      }\n      if let limit = limit {\n        sql.append(\" LIMIT \\(limit)\")\n      }\n      var handle : OpaquePointer? = nil\n      guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n            let statement = handle else { return nil }\n      defer { sqlite3_finalize(statement) }\n      let indices = customSQL != nil ? Schema.lookupColumnIndices(in: statement) : Schema.selectColumnIndices\n      var records = [ RegionUpdate ]()\n      while true {\n        let rc = sqlite3_step(statement)\n        if rc == SQLITE_DONE {\n          break\n        }\n        else if rc != SQLITE_ROW {\n          return nil\n        }\n        records.append(RegionUpdate(statement, indices: indices))\n      }\n      return records\n    }\n  }\n  \n  \/**\n   * Fetch ``RegionUpdate`` records using the base SQLite API.\n   * \n   * If the function returns `nil`, the error can be found using the usual\n   * `sqlite3_errcode` and companions.\n   * \n   * Example:\n   * ```swift\n   * let records = RegionUpdate.fetch(\n   *   from : db,\n   *   sql  : #\"SELECT * FROM region_update\"#\n   * }\n   * \n   * let records = RegionUpdate.fetch(\n   *   from    : db,\n   *   sql     : #\"SELECT * FROM region_update\"#,\n   *   orderBy : \"name\", limit: 5\n   * )\n   * ```\n   * \n   * - Parameters:\n   *   - db: The SQLite database handle (as returned by `sqlite3_open`)\n   *   - sql: Custom SQL yielding ``RegionUpdate`` records.\n   *   - orderBySQL: If set, some SQL that is added as an `ORDER BY` clause (e.g. `name DESC`).\n   *   - limit: An optional fetch limit.\n   * - Returns: The records matching the query, or `nil` if there was an error.\n   *\/\n  @inlinable\n  static func fetch(\n    from db: OpaquePointer!,\n    sql customSQL: String? = nil,\n    orderBy orderBySQL: String? = nil,\n    limit: Int? = nil\n  ) -> [ RegionUpdate ]?\n  {\n    var sql = customSQL ?? RegionUpdate.Schema.select\n    if let orderBySQL = orderBySQL {\n      sql.append(\" ORDER BY \\(orderBySQL)\")\n    }\n    if let limit = limit {\n      sql.append(\" LIMIT \\(limit)\")\n    }\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return nil }\n    defer { sqlite3_finalize(statement) }\n    let indices = customSQL != nil ? Schema.lookupColumnIndices(in: statement) : Schema.selectColumnIndices\n    var records = [ RegionUpdate ]()\n    while true {\n      let rc = sqlite3_step(statement)\n      if rc == SQLITE_DONE {\n        break\n      }\n      else if rc != SQLITE_ROW {\n        return nil\n      }\n      records.append(RegionUpdate(statement, indices: indices))\n    }\n    return records\n  }\n  \n  \/**\n   * Insert a ``RegionUpdate`` record in the SQLite database.\n   * \n   * This operates on a raw SQLite database handle (as returned by\n   * `sqlite3_open`).\n   * \n   * Example:\n   * ```swift\n   * var record = RegionUpdate(...values...)\n   * let rc = record.insert(into: db)\n   * assert(rc == SQLITE_OK)\n   * ```\n   * \n   * - Parameters:\n   *   - db: SQLite3 database handle.\n   * - Returns: The SQLite error code (of `sqlite3_prepare\/step`), e.g. `SQLITE_OK`.\n   *\/\n  @inlinable\n  @discardableResult\n  mutating func insert(into db: OpaquePointer!) -> Int32\n  {\n    let sql = BeenOutside.useInsertReturning ? RegionUpdate.Schema.insertReturning : RegionUpdate.Schema.insert\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return sqlite3_errcode(db) }\n    defer { sqlite3_finalize(statement) }\n    return self.bind(to: statement, indices: RegionUpdate.Schema.insertParameterIndices) {\n      let rc = sqlite3_step(statement)\n      if rc == SQLITE_DONE {\n        var sql = RegionUpdate.Schema.select\n        sql.append(#\" WHERE ROWID = last_insert_rowid()\"#)\n        var handle : OpaquePointer? = nil\n        guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n              let statement = handle else { return sqlite3_errcode(db) }\n        defer { sqlite3_finalize(statement) }\n        let rc = sqlite3_step(statement)\n        if rc == SQLITE_DONE {\n          return SQLITE_OK\n        }\n        else if rc != SQLITE_ROW {\n          return sqlite3_errcode(db)\n        }\n        let record = RegionUpdate(statement, indices: RegionUpdate.Schema.selectColumnIndices)\n        self = record\n        return SQLITE_OK\n      }\n      else if rc != SQLITE_ROW {\n        return sqlite3_errcode(db)\n      }\n      let record = RegionUpdate(statement, indices: RegionUpdate.Schema.selectColumnIndices)\n      self = record\n      return SQLITE_OK\n    }\n  }\n  \n  \/**\n   * Update a ``RegionUpdate`` record in the SQLite database.\n   * \n   * This operates on a raw SQLite database handle (as returned by\n   * `sqlite3_open`).\n   * \n   * Example:\n   * ```swift\n   * let rc = record.update(in: db)\n   * assert(rc == SQLITE_OK)\n   * ```\n   * \n   * - Parameters:\n   *   - db: SQLite3 database handle.\n   * - Returns: The SQLite error code (of `sqlite3_prepare\/step`), e.g. `SQLITE_OK`.\n   *\/\n  @inlinable\n  @discardableResult\n  func update(`in` db: OpaquePointer!) -> Int32\n  {\n    let sql = RegionUpdate.Schema.update\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return sqlite3_errcode(db) }\n    defer { sqlite3_finalize(statement) }\n    return self.bind(to: statement, indices: RegionUpdate.Schema.updateParameterIndices) {\n      let rc = sqlite3_step(statement)\n      return rc != SQLITE_DONE && rc != SQLITE_ROW ? sqlite3_errcode(db) : SQLITE_OK\n    }\n  }\n  \n  \/**\n   * Delete a ``RegionUpdate`` record in the SQLite database.\n   * \n   * This operates on a raw SQLite database handle (as returned by\n   * `sqlite3_open`).\n   * \n   * Example:\n   * ```swift\n   * let rc = record.delete(from: db)\n   * assert(rc == SQLITE_OK)\n   * ```\n   * \n   * - Parameters:\n   *   - db: SQLite3 database handle.\n   * - Returns: The SQLite error code (of `sqlite3_prepare\/step`), e.g. `SQLITE_OK`.\n   *\/\n  @inlinable\n  @discardableResult\n  func delete(from db: OpaquePointer!) -> Int32\n  {\n    let sql = RegionUpdate.Schema.delete\n    var handle : OpaquePointer? = nil\n    guard sqlite3_prepare_v2(db, sql, -1, &handle, nil) == SQLITE_OK,\n          let statement = handle else { return sqlite3_errcode(db) }\n    defer { sqlite3_finalize(statement) }\n    return self.bind(to: statement, indices: RegionUpdate.Schema.deleteParameterIndices) {\n      let rc = sqlite3_step(statement)\n      return rc != SQLITE_DONE && rc != SQLITE_ROW ? sqlite3_errcode(db) : SQLITE_OK\n    }\n  }\n}\n\npublic extension RegionUpdate {\n  \n  \/**\n   * Static type information for the ``RegionUpdate`` record (`region_update` SQL table).\n   * \n   * This structure captures the static SQL information associated with the\n   * record.\n   * It is used for static type lookups and more.\n   *\/\n  struct Schema {\n    \n    public typealias PropertyIndices = ( idx_id: Int32, idx_date: Int32, idx_updateTypeRaw: Int32, idx_regionName: Int32 )\n    public typealias RecordType = RegionUpdate\n    public typealias MatchClosureType = ( RegionUpdate ) -> Bool\n    \n    \/\/\/ The SQL table name associated with the ``RegionUpdate`` record.\n    public static let externalName = \"region_update\"\n    \n    \/\/\/ The number of columns the `region_update` table has.\n    public static let columnCount : Int32 = 4\n    \n    \/\/\/ The SQL used to create the `region_update` table.\n    public static let create = \n      #\"\"\"\n      CREATE TABLE region_update (\n        region_update_id INTEGER PRIMARY KEY,\n        \n        date DATETIME NOT NULL,\n        update_type_raw TEXT NOT NULL,\n        region_name Text\n      );\n      \"\"\"#\n    \n    \/\/\/ SQL to `SELECT` all columns of the `region_update` table.\n    public static let select = #\"SELECT \"region_update_id\", \"date\", \"update_type_raw\", \"region_name\" FROM \"region_update\"\"#\n    \n    \/\/\/ SQL fragment representing all columns.\n    public static let selectColumns = #\"\"region_update_id\", \"date\", \"update_type_raw\", \"region_name\"\"#\n    \n    \/\/\/ Index positions of the properties in ``selectColumns``.\n    public static let selectColumnIndices : PropertyIndices = ( 0, 1, 2, 3 )\n    \n    \/\/\/ SQL to `SELECT` all columns of the `region_update` table using a Swift filter.\n    public static let matchSelect = #\"SELECT \"region_update_id\", \"date\", \"update_type_raw\", \"region_name\" FROM \"region_update\" WHERE regionUpdates_swift_match(\"region_update_id\", \"date\", \"update_type_raw\", \"region_name\") != 0\"#\n    \n    \/\/\/ SQL to `UPDATE` all columns of the `region_update` table.\n    public static let update = #\"UPDATE \"region_update\" SET \"date\" = ?, \"update_type_raw\" = ?, \"region_name\" = ? WHERE \"region_update_id\" = ?\"#\n    \n    \/\/\/ Property parameter indicies in the ``update`` SQL\n    public static let updateParameterIndices : PropertyIndices = ( 4, 1, 2, 3 )\n    \n    \/\/\/ SQL to `INSERT` a record into the `region_update` table.\n    public static let insert = #\"INSERT INTO \"region_update\" ( \"date\", \"update_type_raw\", \"region_name\" ) VALUES ( ?, ?, ? )\"#\n    \n    \/\/\/ SQL to `INSERT` a record into the `region_update` table.\n    public static let insertReturning = #\"INSERT INTO \"region_update\" ( \"date\", \"update_type_raw\", \"region_name\" ) VALUES ( ?, ?, ? ) RETURNING \"region_update_id\", \"date\", \"update_type_raw\", \"region_name\"\"#\n    \n    \/\/\/ Property parameter indicies in the ``insert`` SQL\n    public static let insertParameterIndices : PropertyIndices = ( -1, 1, 2, 3 )\n    \n    \/\/\/ SQL to `DELETE` a record from the `region_update` table.\n    public static let delete = #\"DELETE FROM \"region_update\" WHERE \"region_update_id\" = ?\"#\n    \n    \/\/\/ Property parameter indicies in the ``delete`` SQL\n    public static let deleteParameterIndices : PropertyIndices = ( 1, -1, -1, -1 )\n    \n    \/**\n     * Lookup property indices by column name in a statement handle.\n     * \n     * Properties are ordered in the schema and have a specific index\n     * assigned.\n     * E.g. if the record has two properties, `id` and `name`,\n     * and the query was `SELECT age, region_update_id FROM region_update`,\n     * this would return `( idx_id: 1, idx_name: -1 )`.\n     * Because the `region_update_id` is in the second position and `name`\n     * isn't provided at all.\n     * \n     * - Parameters:\n     *   - statement: A raw SQLite3 prepared statement handle.\n     * - Returns: The positions of the properties in the prepared statement.\n     *\/\n    @inlinable\n    public static func lookupColumnIndices(`in` statement: OpaquePointer!)\n      -> PropertyIndices\n    {\n      var indices : PropertyIndices = ( -1, -1, -1, -1 )\n      for i in 0..<sqlite3_column_count(statement) {\n        let col = sqlite3_column_name(statement, i)\n        if strcmp(col!, \"region_update_id\") == 0 {\n          indices.idx_id = i\n        }\n        else if strcmp(col!, \"date\") == 0 {\n          indices.idx_date = i\n        }\n        else if strcmp(col!, \"update_type_raw\") == 0 {\n          indices.idx_updateTypeRaw = i\n        }\n        else if strcmp(col!, \"region_name\") == 0 {\n          indices.idx_regionName = i\n        }\n      }\n      return indices\n    }\n    \n    \/**\n     * Register the Swift matcher function for the ``RegionUpdate`` record.\n     * \n     * SQLite Swift matcher functions are used to process `filter` queries\n     * and low-level matching w\/o the Lighter library.\n     * \n     * - Parameters:\n     *   - unsafeDatabaseHandle: SQLite3 database handle.\n     *   - flags: SQLite3 function registration flags, default: `SQLITE_UTF8`\n     *   - matcher: A pointer to the Swift closure used to filter the records.\n     * - Returns: The result code of `sqlite3_create_function`, e.g. `SQLITE_OK`.\n     *\/\n    @inlinable\n    @discardableResult\n    public static func registerSwiftMatcher(\n      `in` unsafeDatabaseHandle: OpaquePointer!,\n      flags: Int32 = SQLITE_UTF8,\n      matcher: UnsafeRawPointer\n    ) -> Int32\n    {\n      func dispatch(\n        _ context: OpaquePointer?,\n        argc: Int32,\n        argv: UnsafeMutablePointer<OpaquePointer?>!\n      )\n      {\n        if let closureRawPtr = sqlite3_user_data(context) {\n          let closurePtr = closureRawPtr.bindMemory(to: MatchClosureType.self, capacity: 1)\n          let indices = RegionUpdate.Schema.selectColumnIndices\n          let record = RegionUpdate(\n            id: (indices.idx_id >= 0) && (indices.idx_id < argc) ? (sqlite3_value_type(argv[Int(indices.idx_id)]) != SQLITE_NULL ? Int(sqlite3_value_int64(argv[Int(indices.idx_id)])) : nil) : nil,\n            date: ((indices.idx_date >= 0) && (indices.idx_date < argc) && (sqlite3_value_type(argv[Int(indices.idx_date)]) != SQLITE_NULL) ? (sqlite3_value_type(argv[Int(indices.idx_date)]) == SQLITE_TEXT ? (sqlite3_value_text(argv[Int(indices.idx_date)]).flatMap({ BeenOutside.dateFormatter?.date(from: String(cString: $0)) })) : Date(timeIntervalSince1970: sqlite3_value_double(argv[Int(indices.idx_date)]))) : nil) ?? Date(timeIntervalSince1970: 0),\n            updateTypeRaw: ((indices.idx_updateTypeRaw >= 0) && (indices.idx_updateTypeRaw < argc) ? (sqlite3_value_text(argv[Int(indices.idx_updateTypeRaw)]).flatMap(String.init(cString:))) : nil) ?? \"\",\n            regionName: (indices.idx_regionName >= 0) && (indices.idx_regionName < argc) ? (sqlite3_value_text(argv[Int(indices.idx_regionName)]).flatMap(String.init(cString:))) : nil\n          )\n          sqlite3_result_int(context, closurePtr.pointee(record) ? 1 : 0)\n        }\n        else {\n          sqlite3_result_error(context, \"Missing Swift matcher closure\", -1)\n        }\n      }\n      return sqlite3_create_function(\n        unsafeDatabaseHandle,\n        \"regionUpdates_swift_match\",\n        RegionUpdate.Schema.columnCount,\n        flags,\n        UnsafeMutableRawPointer(mutating: matcher),\n        dispatch,\n        nil,\n        nil\n      )\n    }\n    \n    \/**\n     * Unregister the Swift matcher function for the ``RegionUpdate`` record.\n     * \n     * SQLite Swift matcher functions are used to process `filter` queries\n     * and low-level matching w\/o the Lighter library.\n     * \n     * - Parameters:\n     *   - unsafeDatabaseHandle: SQLite3 database handle.\n     *   - flags: SQLite3 function registration flags, default: `SQLITE_UTF8`\n     * - Returns: The result code of `sqlite3_create_function`, e.g. `SQLITE_OK`.\n     *\/\n    @inlinable\n    @discardableResult\n    public static func unregisterSwiftMatcher(\n      `in` unsafeDatabaseHandle: OpaquePointer!,\n      flags: Int32 = SQLITE_UTF8\n    ) -> Int32\n    {\n      sqlite3_create_function(\n        unsafeDatabaseHandle,\n        \"regionUpdates_swift_match\",\n        RegionUpdate.Schema.columnCount,\n        flags,\n        nil,\n        nil,\n        nil,\n        nil\n      )\n    }\n  }\n  \n  \/**\n   * Initialize a ``RegionUpdate`` record from a SQLite statement handle.\n   * \n   * This initializer allows easy setup of a record structure from an\n   * otherwise arbitrarily constructed SQLite prepared statement.\n   * \n   * If no `indices` are specified, the `Schema\/lookupColumnIndices`\n   * function will be used to find the positions of the structure properties\n   * based on their external name.\n   * When looping, it is recommended to do the lookup once, and then\n   * provide the `indices` to the initializer.\n   * \n   * Required values that are missing in the statement are replaced with\n   * their assigned default values, i.e. this can even be used to perform\n   * partial selects w\/ only a minor overhead (the extra space for a\n   * record).\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(dbHandle, \"SELECT * FROM region_update\", -1, &statement, nil)\n   * while sqlite3_step(statement) == SQLITE_ROW {\n   *   let record = RegionUpdate(statement)\n   *   print(\"Fetched:\", record)\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: Statement handle as returned by `sqlite3_prepare*` functions.\n   *   - indices: Property bindings positions, defaults to `nil` (automatic lookup).\n   *\/\n  @inlinable\n  init(_ statement: OpaquePointer!, indices: Schema.PropertyIndices? = nil)\n  {\n    let indices = indices ?? Self.Schema.lookupColumnIndices(in: statement)\n    let argc = sqlite3_column_count(statement)\n    self.init(\n      id: (indices.idx_id >= 0) && (indices.idx_id < argc) ? (sqlite3_column_type(statement, indices.idx_id) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_id)) : nil) : nil,\n      date: ((indices.idx_date >= 0) && (indices.idx_date < argc) && (sqlite3_column_type(statement, indices.idx_date) != SQLITE_NULL) ? (sqlite3_column_type(statement, indices.idx_date) == SQLITE_TEXT ? (sqlite3_column_text(statement, indices.idx_date).flatMap({ BeenOutside.dateFormatter?.date(from: String(cString: $0)) })) : Date(timeIntervalSince1970: sqlite3_column_double(statement, indices.idx_date))) : nil) ?? Date(timeIntervalSince1970: 0),\n      updateTypeRaw: ((indices.idx_updateTypeRaw >= 0) && (indices.idx_updateTypeRaw < argc) ? (sqlite3_column_text(statement, indices.idx_updateTypeRaw).flatMap(String.init(cString:))) : nil) ?? \"\",\n      regionName: (indices.idx_regionName >= 0) && (indices.idx_regionName < argc) ? (sqlite3_column_text(statement, indices.idx_regionName).flatMap(String.init(cString:))) : nil\n    )\n  }\n  \n  \/**\n   * Bind all ``RegionUpdate`` properties to a prepared statement and call a closure.\n   * \n   * *Important*: The bindings are only valid within the closure being executed!\n   * \n   * Example:\n   * ```swift\n   * var statement : OpaquePointer?\n   * sqlite3_prepare_v2(\n   *   dbHandle,\n   *   #\"UPDATE \"region_update\" SET \"date\" = ?, \"update_type_raw\" = ?, \"region_name\" = ? WHERE \"region_update_id\" = ?\"#,\n   *   -1, &statement, nil\n   * )\n   * \n   * let record = RegionUpdate(id: 1, date: ..., updateTypeRaw: \"Hello\", regionName: \"World\")\n   * let ok = record.bind(to: statement, indices: ( 4, 1, 2, 3 )) {\n   *   sqlite3_step(statement) == SQLITE_DONE\n   * }\n   * sqlite3_finalize(statement)\n   * ```\n   * \n   * - Parameters:\n   *   - statement: A SQLite3 statement handle as returned by the `sqlite3_prepare*` functions.\n   *   - indices: The parameter positions for the bindings.\n   *   - execute: Closure executed with bindings applied, bindings _only_ valid within the call!\n   * - Returns: Returns the result of the closure that is passed in.\n   *\/\n  @inlinable\n  @discardableResult\n  func bind<R>(\n    to statement: OpaquePointer!,\n    indices: Schema.PropertyIndices,\n    then execute: () throws -> R\n  ) rethrows -> R\n  {\n    if indices.idx_id >= 0 {\n      if let id = id {\n        sqlite3_bind_int64(statement, indices.idx_id, Int64(id))\n      }\n      else {\n        sqlite3_bind_null(statement, indices.idx_id)\n      }\n    }\n    if indices.idx_date >= 0 {\n      sqlite3_bind_double(statement, indices.idx_date, date.timeIntervalSince1970)\n    }\n    return try updateTypeRaw.withCString() { ( s ) in\n      if indices.idx_updateTypeRaw >= 0 {\n        sqlite3_bind_text(statement, indices.idx_updateTypeRaw, s, -1, nil)\n      }\n      return try BeenOutside.withOptCString(regionName) { ( s ) in\n        if indices.idx_regionName >= 0 {\n          sqlite3_bind_text(statement, indices.idx_regionName, s, -1, nil)\n        }\n        return try execute()\n      }\n    }\n  }\n}\n"}